#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>

using namespace std;

int row_dir[] = { 0, -1, 0, 1 };
int col_dir[] = { 1, 0, -1, 0 };

class RotatingBot {
public:
    bool is_valid( int row, int col, int rrow, int ccol )
    {
        if( row >= 0 && col >= 0 && row < rrow && col < ccol ) return true;
        return false;
    }

    bool hasAMove( int row, int col, vector < vector <bool> > board )
    {
        return ( is_valid( row + 1, col, board.size(), board[0].size() ) && !board[row + 1][col] ) ||
        ( is_valid( row - 1, col, board.size(), board[0].size() ) && !board[row - 1][col] ) ||
        ( is_valid( row, col + 1, board.size(), board[0].size() ) && !board[row][col + 1] ) ||
        ( is_valid( row, col - 1, board.size(), board[0].size() ) && !board[row][col - 1] );
    }
    
    vector <int> gen( int row, int col, int rrow, int ccol, vector < vector <bool> > board )
    {
        vector <int> gen_moves;
    
        int direction = 0;
        int num_cur_direction = 0;

        int turn_count = 0;
    
        while( turn_count < 2 && hasAMove( row, col, board ) )
        {
            int new_row = row + row_dir[direction];
            int new_col = col + col_dir[direction];
    
            if( is_valid( new_row, new_col, rrow, ccol ) && !board[new_row][new_col] ) 
            {
                num_cur_direction++;
                board[new_row][new_col] = true;
                row = new_row, col = new_col;
                turn_count = 0;
            }
            else
            {
                direction = (direction + 1) % 4;
                if( num_cur_direction == 0 ) break;
                gen_moves.push_back( num_cur_direction );
                num_cur_direction = 0;
                turn_count++;
            }
        }
    
        return gen_moves;
    }

    bool move( int& direction, vector < vector <bool> >& board, int& row, int& col )
    {
        int new_row = row + row_dir[direction];
        int new_col = col + col_dir[direction];

        if( is_valid( new_row, new_col, board.size(), board[0].size() ) && board[new_row][new_col] != true )
        {
            row = new_row, col = new_col;
            board[new_row][new_col] = true;
            return true;
        }
        else
        {
            return false;
        }
    }

	int minArea(vector <int> moves)
    {
        vector <bool> board_t( 200, false );
        vector < vector <bool> > board( 200, board_t );

        int direction = 0;

        int sr = 100, sc = 100;
        board[sr][sc] = true;
        
        bool can;
        for( int i = 0; i < moves.size(); i++ )
        {
            for( int j = 0; j < moves[i]; j++ )
            {
                can = move( direction, board, sr, sc );
                if( !can ) return -1;
            }
            direction = ( direction + 1 ) % 4;
        }

        int fr = 201, fc = 201, lr = -201, lc = -201;
        for( int i = 0; i < 200; i++ )
        {
            for( int j = 0; j < 200; j++ )
            {
                if( board[i][j] )
                    fr = min( fr, i );

                if( board[i][j] )
                    fc = min( fc, j );

                if( board[i][j] )
                    lr = max( lr, i );

                if( board[i][j] )
                    lc = max( lc, j );
            }
        }

        int length = lr - fr + 1;
        int width = lc - fc + 1;

        vector <int> generated_moves = gen( length - 1, 0, length, width, board );

        for( int i = 0; i < generated_moves.size(); i++ )
            cout << generated_moves[i] << " ";
        cout << endl;

        if( generated_moves != moves ) return -1;

        return length * width;
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, vector <int> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}";
	cout << "]" << endl;
	RotatingBot *obj;
	int answer;
	obj = new RotatingBot();
	clock_t startTime = clock();
	answer = obj->minArea(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <int> p0;
	int p1;
	
	{
	// ----- test 0 -----
	int t0[] = {15};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 16;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	int t0[] = {3,10};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 44;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	int t0[] = {1,1,1,1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = -1;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	int t0[] = {9,5,11,10,11,4,10};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 132;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	int t0[] = {12,1,27,14,27,12,26,11,25,10,24,9,23,8,22,7,21,6,20,5,19,4,18,3,17,2,16,1,15};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 420;
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	int t0[] = {8,6,6,1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = -1;
	all_right = KawigiEdit_RunTest(5, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 6 -----
	int t0[] = {8,6,6};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 63;
	all_right = KawigiEdit_RunTest(6, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 7 -----
	int t0[] = {5,4,5,3,3};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 30;
	all_right = KawigiEdit_RunTest(7, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
